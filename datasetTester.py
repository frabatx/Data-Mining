# - * - coding: utf-8 - * - 
"""Dataset generator
This module creates a dataset generated by trees.
The dataset is structured as follows:
    * Create a seed, a list of lists that contain n random integer.
    * Fills the seed with noise
    * Builds a tree from a sequence
    * Adds noise to the tree by adding random nodes
    * Generates the dataset
"""

import random
import copy
import csv
from random import shuffle, randint
from Binary_Tree import BinaryTree


def createSequence(n_list, max_range):
    """Create a seed

    Arguments:
        n_list {integer} -- [Number of lists inside the seed]
        max_range {integer} -- [Max value inside the seed]

    Returns:
        [list] -- [It rapresents the seed of a single tree]
        Example: 
            * [[4],[7],[1]]
            * [[1,8],[5],[3,9]]
            * [[4],[5,6],[8]]
    """
    aSeq = []
    for i in range(1, n_list):
        if random.random() < 0.5:
            aSeq.append([randint(0,max_range)])
        else:
            aSeq.append([randint(0,max_range), randint(0,max_range)])
    return aSeq


def seqFiller(seq, n_max):
    """Filling
    The function fills a list with random numbers up to a maximum number of values.
    
    Arguments:
        seq {[list]} -- [list of lists]
        n_max {[integer]} -- [maximum number of values inside internal lists]
    
    Returns:
        [list] -- [A copy of the original list, filled by random numbers]
    """
    seqfilled = copy.deepcopy(seq) #deep copy original list and modify only the copy
    for i in seqfilled:
        while len(i) < n_max:
            i.append(randint(0,9))
    return seqfilled #return copy list - original list "seq" untouched


def seqTreeBuilder(aSeq):
    """Given a sequence, the function bild a tree
    
    Arguments:
        aSeq {list} -- [generic list]
    
    Returns:
        [tree] -- [Binary tree]
    """
    tree = BinaryTree(aSeq[0]) #root node
    randNum = randint(1,4)
    if randNum == 1:
        tree.left = BinaryTree(aSeq[1]) 
        tree.left.left = BinaryTree(aSeq[2]) 
    if randNum == 2: 
        tree.left = BinaryTree(aSeq[1]) 
        tree.left.right = BinaryTree(aSeq[2]) 
    if randNum == 3:
        tree.right = BinaryTree(aSeq[1]) 
        tree.right.right = BinaryTree(aSeq[2])
    if randNum == 4:
        tree.right = BinaryTree(aSeq[1])
        tree.right.left = BinaryTree(aSeq[2])
    return tree 


def createList(max_seq_value, max_range):
    """Create a list of random values, this list is used as single random node in the tree.
    
    Arguments:
        max_seq_value {[int]} -- [Number of values in a list]
        max_range {[int]} -- [Max value of a random integer]
    
    Returns:
        [list] -- [list of integer]
    """
    list = []
    for i in range(0,max_seq_value):
        list.append(randint(1,max_range))
    return list


def addNodesTree(tree, tree_noise, max_seq_value, max_range):
    """the function inserts n random nodes in a tree, this nodes are used as noise inside the tree
    
    Arguments:
        tree {[tree]} -- [The tree where the function has to append random nodes]
        tree_noise {[int]} -- [Number of nodes to append in a tree]
        max_seq_value {[int]} -- [Number of values in a list]
        max_range {[int]} -- [Max value of random integer]
    """
    for i in range(1,tree_noise):
        aList = createList(max_seq_value, max_range)
        tree.insertTraversal(aList)


def records2(tree, t_id, r_id, aList):
    """Given a tree the function builds a dataset as follows: 
        * Record id
        * Tree id
        * Pair of nodes in a parent-child relationship
    
    Arguments:
        tree {[tree]}
        t_id {[int]} -- [Non-negative integer, it is the tree id, is equal in all pairs of nodes belong the same tree]
        r_id {[int]} -- [Non-negative integer, it is the record id, is unique and consecutive]
        aList {[list]} -- [Is the list that contains information about a tree]
    
    Returns:
        [record] -- [Recursive, it is used to print the entire dataset]
    """
    r_id = r_id + 1
    if tree.left != None:
        #print output to screen
        print(str(r_id) + ';' + str(t_id) + ';' , tree.data , tree.left.data)
        #save output in a list
        aList.append([r_id,t_id,tree.data, tree.left.data])
        r_id = records2(tree.left, t_id, r_id, aList)
    if tree.right != None:
        #print output to screen
        print(str(r_id) + ';' + str(t_id) + ';' , tree.data , tree.right.data)
        #save output in a list
        aList.append([r_id,t_id,tree.data, tree.right.data])
        r_id = records2(tree.right, t_id, r_id, aList)
    return r_id

def print_dataset(dataset_list):
    """Writing entire dataset in a csv
    
    Arguments:
        dataset_list {[list]} -- [List of r_id, t_id, pair of nodes in a parent-child relationship]
    """
    with open('dataset1k.csv', 'w') as csvfile:
        csvwriter = csv.writer(csvfile)
        for row in dataset_list:
            csvwriter.writerow(row)

def dataset_generator (n_tree, max_seq_value, n_sequences, max_range, tree_noise):
    """Dataset generator. Once the parameters have been set, a dataset can be built.
        * A seed is generated
        * The seed is then filled with noise (other random numbers)
        * A tree is generated
        * Noise is added to the tree
        * A new record is built
    
    Arguments:
        n_tree {[int]} -- [Numbers of trees generated]
        max_seq_value {[int]} -- [Number of values in a list, the list is used as seed lenght]
        n_sequences {[int]} -- [Number of seeds generated]
        max_range {[int]} -- [Max value in random range]
        tree_noise {[int]} -- [Number of nodes used as noise in a tree]
    """
    r_id = 0
    t_id = 0
    treeList = []
    #Creating sequences
    for sequences in range(1, n_sequences):
        seq = createSequence(max_seq_value, max_range) #creating sequence
        print("\n Sequence created: ", seq)
        seqfilled = seqFiller(seq, max_seq_value) #filled sequence
        print(" Sequence filled: ", seqfilled)
        #creating trees
        for n_trees in range(1, n_tree):
            t_id = t_id + 1
            tree = seqTreeBuilder(seqfilled) #from filled sequence to tree
            addNodesTree(tree,tree_noise, max_seq_value, max_range) #adding noise
            r_id = records2(tree, t_id, r_id, treeList)
            r_id = r_id - 1
            print("\n Tree n: ", n_trees)
            print(tree)
    print_dataset(treeList)
 

#generator_sequences(4,4,9)
n_tree = 4
max_seq_value = 4
n_sequences = 2
max_range = 9
tree_noise = 6
node_noise = 5

dataset_generator(n_tree,max_seq_value,n_sequences,max_range,tree_noise)
